import { mkdir, readFile, writeFile } from "node:fs/promises";
import { join } from "node:path";
import { containsServerExport, getAST } from "../utils/ast";
import { CACHE_FOLDER, GLOB, ROUTES_PATH } from "../utils/constants";

const BANNER
  = `
//! THIS FILE IS AUTOMATICALLY GENERATED BY "satone" CLI
//! DURING "build" AND "dev" COMMANDS.
`.trim() + "\n\n";

const checkCacheFolder = async (): Promise<void> => {
  await mkdir(CACHE_FOLDER, { recursive: true });
};

const write = async (file: string, content: string): Promise<void> => {
  await Bun.write(join(CACHE_FOLDER, file), content);
};

/**
 * Will distribute the types under `node_modules/.satone/eden.d.ts`
 */
const generateEdenTypes = async (): Promise<void> => {
  await checkCacheFolder();

  let output = BANNER + `import Elysia from "elysia";\n\n`;
  const routes: string[] = [];

  for await (const file of GLOB.scan(ROUTES_PATH)) {
    const code = await readFile(join(ROUTES_PATH, file), "utf8");

    // Check if there's a server export in this route.
    const ast = getAST(code);
    if (!containsServerExport(ast)) continue;

    const route = "/" + file.replace("index", "").replace(/\.ts[x]/, "");

    output += `import { server as plug${routes.length} } from ${JSON.stringify(
      join("..", "..", "src", "routes", file)
    )};\n`;

    routes.push(route);
  }

  output += `\nconst app = new Elysia()`;
  for (let curr = 0; curr < routes.length; curr++) {
    const route = routes[curr];
    output += `\n  .group(${JSON.stringify(
      route
    )}, (app) => app.use(plug${curr}))`;
  }

  output += `;\n\nexport type App = typeof app;\n`;
  await write("eden.ts", output);
};

const generateIndexDTS = async (): Promise<void> => {
  await checkCacheFolder();

  let output = BANNER + `import type { App } from "./eden";\n\n`;

  output
    += `
declare global {
  export type SatoneServerRoutes = App;
}
  `.trim() + "\n";

  await write("index.d.ts", output);
};

export const generateTypes = async (): Promise<void> => {
  await generateIndexDTS();
  await generateEdenTypes();
};
